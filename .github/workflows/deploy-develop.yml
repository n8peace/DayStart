name: Deploy to Development

on:
  push:
    branches: [ develop ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: 'false'

jobs:
  deploy-develop:
    name: Deploy to Development
    runs-on: ubuntu-latest
    environment: develop
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'
        
    - name: Setup Supabase CLI
      uses: supabase/setup-cli@v1
      with:
        version: '1.145.4'  # Pin to specific version for stability
        
    - name: Validate environment variables
      run: |
        echo "üîç Validating development environment variables..."
        
        # Check each secret directly
        if [ -z "${{ secrets.SUPABASE_URL }}" ]; then
          echo "‚ùå Missing required environment variable: SUPABASE_URL"
          exit 1
        else
          echo "‚úÖ SUPABASE_URL is set"
        fi
        
        if [ -z "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ]; then
          echo "‚ùå Missing required environment variable: SUPABASE_SERVICE_ROLE_KEY"
          exit 1
        else
          echo "‚úÖ SUPABASE_SERVICE_ROLE_KEY is set"
        fi
        
        if [ -z "${{ secrets.SUPABASE_DEVELOP_PROJECT }}" ]; then
          echo "‚ùå Missing required environment variable: SUPABASE_DEVELOP_PROJECT"
          exit 1
        else
          echo "‚úÖ SUPABASE_DEVELOP_PROJECT is set"
        fi
        
        if [ -z "${{ secrets.SUPABASE_ACCESS_TOKEN }}" ]; then
          echo "‚ùå Missing required environment variable: SUPABASE_ACCESS_TOKEN"
          exit 1
        else
          echo "‚úÖ SUPABASE_ACCESS_TOKEN is set"
        fi
        
        if [ -z "${{ secrets.SUPABASE_DB_PASSWORD }}" ]; then
          echo "‚ùå Missing required environment variable: SUPABASE_DB_PASSWORD"
          exit 1
        else
          echo "‚úÖ SUPABASE_DB_PASSWORD is set"
        fi
        
        echo "‚úÖ All required environment variables are set"
        
    - name: Verify Supabase access and list projects
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      run: |
        echo "üîç Verifying Supabase access..."
        echo "üîç Testing access token..."
        
        # Test if we can list projects
        if supabase projects list; then
          echo "‚úÖ Access token is valid"
          echo "üìã All accessible projects:"
          supabase projects list
        else
          echo "‚ùå Access token is invalid or expired"
          echo "üîß Please check SUPABASE_ACCESS_TOKEN secret"
          exit 1
        fi
        
    - name: Link to development project
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      run: |
        cd supabase
        echo "Linking to development project: ${{ secrets.SUPABASE_DEVELOP_PROJECT }}"
        supabase link --project-ref ${{ secrets.SUPABASE_DEVELOP_PROJECT }}
        
    - name: Deploy database migrations
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
      run: |
        cd supabase
        echo "Deploying database migrations to development..."
        
        # Set the database password for the connection
        export PGPASSWORD="${{ secrets.SUPABASE_DB_PASSWORD }}"
        
        echo "Attempting database migration deployment..."
        
        # Test database connectivity first using a simple query
        echo "üîç Testing database connectivity before migration..."
        echo "üîç Verifying project link..."
        
        # Check if project is properly linked
        echo "üîç Looking for project: ${{ secrets.SUPABASE_DEVELOP_PROJECT }}"
        echo "üîç Available projects:"
        supabase projects list
        
        # Check if the target project exists in the list
        if ! supabase projects list | grep -q "${{ secrets.SUPABASE_DEVELOP_PROJECT }}"; then
          echo "‚ùå Project ${{ secrets.SUPABASE_DEVELOP_PROJECT }} not found in linked projects"
          echo "üîç Available project reference IDs:"
          supabase projects list | grep -E '^[[:space:]]*[a-zA-Z0-9]+' | awk '{print $3}'
          echo ""
          echo "üîß Troubleshooting steps:"
          echo "   1. Verify SUPABASE_ACCESS_TOKEN has access to project epqiarnkhzabggxiltci"
          echo "   2. Check if project epqiarnkhzabggxiltci exists and is accessible"
          echo "   3. Try linking directly: supabase link --project-ref epqiarnkhzabggxiltci"
          echo "   4. Verify you're using the correct Supabase account"
          echo ""
          echo "üîç Testing direct project link..."
          if supabase link --project-ref ${{ secrets.SUPABASE_DEVELOP_PROJECT }}; then
            echo "‚úÖ Direct project link successful"
          else
            echo "‚ùå Direct project link failed"
            exit 1
          fi
        fi
        
        echo "‚úÖ Project is properly linked"
        
        # Attempt migration with retry logic
        echo "üîÑ Attempting database migration..."
        max_retries=3
        retry_count=0
        
        while [ $retry_count -lt $max_retries ]; do
          echo "üîÑ Migration attempt $((retry_count + 1)) of $max_retries..."
          if supabase db push --debug; then
            echo "‚úÖ Database migration successful"
            break
          else
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
              echo "‚ö†Ô∏è Migration failed, retrying in 10 seconds..."
              sleep 10
            else
              echo "‚ùå Database migration failed after $max_retries attempts"
              echo "üîç Checking migration status..."
              supabase migration list || echo "Could not list migrations"
              echo "üîç Checking for network connectivity issues..."
              echo "üîç This may be due to:"
              echo "   - Network connectivity issues"
              echo "   - Database credentials"
              echo "   - Database server status"
              exit 1
            fi
          fi
        done
        
        echo "‚úÖ Database migrations deployed successfully"
        
    - name: Verify database schema
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      run: |
        cd supabase
        echo "üîç Verifying database schema after migrations..."
        
        # Test if the content_blocks table exists and has correct constraints
        schema_test=$(curl -s -w "\n%{http_code}" -X GET "${{ secrets.SUPABASE_URL }}/rest/v1/content_blocks?select=id&limit=1" \
          -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
          -H "Content-Type: application/json" 2>/dev/null || echo "Schema test failed")
        
        http_code=$(echo "$schema_test" | tail -n1)
        if [ "$http_code" = "200" ]; then
          echo "‚úÖ Database schema verification passed"
        else
          echo "‚ö†Ô∏è Database schema verification failed (HTTP $http_code)"
          echo "This may be normal for a fresh deployment"
        fi
        
    - name: Remove Legacy Functions
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      run: |
        cd supabase
        echo "Removing legacy functions..."
        # Remove legacy functions that are no longer needed
        supabase functions delete generate-message --project-ref ${{ secrets.SUPABASE_DEVELOP_PROJECT }} || echo "generate-message not found or already removed"
        supabase functions delete test-voice --project-ref ${{ secrets.SUPABASE_DEVELOP_PROJECT }} || echo "test-voice not found or already removed"
        echo "Legacy function removal complete"
        
    - name: Deploy Edge Functions
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      run: |
        cd supabase
        echo "üöÄ Deploying edge functions to development..."
        echo "Current directory: $(pwd)"
        echo "Git commit hash: $(git rev-parse HEAD)"
        echo "Git branch: $(git branch --show-current)"
        echo "Functions directory contents:"
        ls -la functions/ || echo "Functions directory not found"
        
        # Check if any functions exist to deploy
        if [ -d "functions" ] && [ "$(ls -A functions)" ]; then
          echo "Found functions, deploying individually..."
          
          # Deploy each function individually with improved error handling
          failed_functions=()
          
          for func_dir in functions/*/; do
            if [ -d "$func_dir" ]; then
              func_name=$(basename "$func_dir")
              if [ "$func_name" = "shared" ]; then
                echo "‚è≠Ô∏è Skipping shared directory (not a function)"
                continue
              fi
              
              echo "üöÄ Deploying function: $func_name"
              echo "üìÅ Function directory: $func_dir"
              echo "üìÑ Function files:"
              ls -la "$func_dir"
              
              # Deploy with enhanced error handling and no force deletion
              echo "üöÄ Deploying function: $func_name"
              if supabase functions deploy $func_name --project-ref ${{ secrets.SUPABASE_DEVELOP_PROJECT }} --no-verify-jwt --debug; then
                echo "‚úÖ Successfully deployed function: $func_name"
              else
                echo "‚ùå Failed to deploy function: $func_name"
                failed_functions+=("$func_name")
              fi
            fi
          done
          
          # Report deployment results
          if [ ${#failed_functions[@]} -eq 0 ]; then
            echo "‚úÖ All function deployments completed successfully"
          else
            echo "‚ùå Some function deployments failed:"
            printf '  - %s\n' "${failed_functions[@]}"
            echo "üîç Checking function status..."
            supabase functions list --project-ref ${{ secrets.SUPABASE_DEVELOP_PROJECT }} || echo "Could not list functions"
            exit 1
          fi
          
          # List deployed functions
          echo "üìã Deployed functions:"
          supabase functions list --project-ref ${{ secrets.SUPABASE_DEVELOP_PROJECT }} || echo "Could not list functions"
        else
          echo "‚ö†Ô∏è No functions to deploy - functions directory is empty"
        fi
        
    - name: Verify function deployment
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      run: |
        cd supabase
        echo "üîç Verifying function deployment status..."
        
        # Get list of deployed functions
        deployed_functions=$(supabase functions list --project-ref ${{ secrets.SUPABASE_DEVELOP_PROJECT }} 2>/dev/null | grep -E '^[a-zA-Z0-9-]+' | awk '{print $1}' || echo "")
        
        if [ -z "$deployed_functions" ]; then
          echo "‚ö†Ô∏è No functions found in deployment"
        else
          echo "‚úÖ Deployed functions:"
          echo "$deployed_functions"
        fi
        
    - name: Run health checks
      run: |
        echo "üè• Running health checks..."
        
        # Check if any functions exist before testing them
        if [ -d "supabase/functions" ] && [ "$(ls -A supabase/functions)" ]; then
          echo "Testing edge functions with detailed logging..."
          
          # Create a temporary file to store function names
          temp_file=$(mktemp)
          
          # Collect all function names (skip shared directory)
          for func_dir in supabase/functions/*/; do
            if [ -d "$func_dir" ]; then
              func_name=$(basename "$func_dir")
              if [ "$func_name" = "shared" ]; then
                echo "‚è≠Ô∏è Skipping shared directory (not a function)"
                continue
              fi
              echo "$func_name" >> "$temp_file"
            fi
          done
          
          echo "üìã Functions to test:"
          cat "$temp_file"
          
          # Function to test a single function with detailed logging
          test_function() {
            local func_name=$1
            echo "üîç Testing $func_name function..."
            
            # Test with detailed response logging
            echo "  üì° Making request to: ${{ secrets.SUPABASE_URL }}/functions/v1/$func_name"
            
            # Capture full response with headers and body
            full_response=$(timeout 30 curl -s -w "\n---HTTP_CODE---%{http_code}\n---RESPONSE_TIME---%{time_total}s" \
              -X GET "${{ secrets.SUPABASE_URL }}/functions/v1/$func_name" \
              -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
              -H "Content-Type: application/json" \
              -v 2>&1)
            
            # Extract HTTP code using awk to get value after marker
            http_code=$(echo "$full_response" | awk -F'---HTTP_CODE---' '{if (NF>1) print $2}' | awk -F'---RESPONSE_TIME---' '{print $1}' | tr -d '\n ')
            
            # Extract response time using awk to get value after marker
            response_time=$(echo "$full_response" | awk -F'---RESPONSE_TIME---' '{if (NF>1) print $2}' | tr -d 's\n ')
            
            # Extract response body (everything before the HTTP_CODE marker)
            response_body=$(echo "$full_response" | sed '/---HTTP_CODE---/,$d' | tail -n +2)
            
            echo "  ‚è±Ô∏è Response time: ${response_time}s"
            echo "  üìä HTTP Status: $http_code"
            
            # Log response body for debugging (truncated if too long)
            if [ ${#response_body} -gt 500 ]; then
              echo "  üìÑ Response body (truncated): ${response_body:0:500}..."
            else
              echo "  üìÑ Response body: $response_body"
            fi
            
            # Determine if the function is healthy
            if [ "$http_code" = "200" ]; then
              echo "  ‚úÖ $func_name function is healthy"
              return 0
            elif [ "$func_name" = "generate-weather-content" ] && [ "$http_code" = "400" ]; then
              echo "  ‚úÖ $func_name function is healthy (no weather data available - expected)"
              return 0
            elif [ "$http_code" = "503" ]; then
              echo "  ‚ö†Ô∏è $func_name function returned 503 (Service Unavailable)"
              echo "  üîç This usually means internal health checks failed"
              return 1
            elif [ "$http_code" = "500" ]; then
              echo "  ‚ùå $func_name function crashed (HTTP 500)"
              echo "  üîç Check Supabase logs for detailed error"
              return 1
            else
              echo "  ‚ùå $func_name function health check failed (HTTP $http_code)"
              return 1
            fi
          }
          
          # Export the function and variables for parallel execution
          export -f test_function
          export SUPABASE_URL="${{ secrets.SUPABASE_URL }}"
          export SUPABASE_SERVICE_ROLE_KEY="${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}"
          
          # Run health checks sequentially for better logging
          echo "üöÄ Starting function health checks..."
          failed_functions=()
          
          while IFS= read -r func_name; do
            if ! test_function "$func_name"; then
              failed_functions+=("$func_name")
            fi
            echo ""  # Add spacing between function tests
          done < "$temp_file"
          
          # Clean up
          rm -f "$temp_file"
          
          # Report results
          if [ ${#failed_functions[@]} -eq 0 ]; then
            echo "‚úÖ All function health checks passed"
          else
            echo "‚ùå Health check failures detected:"
            printf '  - %s\n' "${failed_functions[@]}"
            echo ""
            echo "üîß Debugging steps:"
            echo "  1. Check Supabase dashboard ‚Üí Edge Functions ‚Üí [Function Name] ‚Üí Logs"
            echo "  2. Verify environment variables are set correctly"
            echo "  3. Check if database migrations have been applied"
            echo "  4. Review function code for unhandled errors"
            exit 1
          fi
          
          echo "‚úÖ All function health checks completed"
        else
          echo "‚ö†Ô∏è No functions to test - functions directory is empty"
        fi
        
        # Test database connectivity with detailed logging
        echo ""
        echo "üóÑÔ∏è Testing database connectivity..."
        echo "  üì° Making request to: ${{ secrets.SUPABASE_URL }}/rest/v1/users?select=count"
        
        db_response=$(curl -s -w "\n---HTTP_CODE---%{http_code}\n---RESPONSE_TIME---%{time_total}s" \
          -X GET "${{ secrets.SUPABASE_URL }}/rest/v1/users?select=count" \
          -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
          -H "Content-Type: application/json" \
          -v 2>&1)
        
        db_http_code=$(echo "$db_response" | grep -- "---HTTP_CODE---" | cut -d'-' -f4)
        db_response_time=$(echo "$db_response" | grep -- "---RESPONSE_TIME---" | cut -d'-' -f4)
        db_response_body=$(echo "$db_response" | sed '/---HTTP_CODE---/,$d' | tail -n +2)
        
        echo "  ‚è±Ô∏è Response time: ${db_response_time}s"
        echo "  üìä HTTP Status: $db_http_code"
        echo "  üìÑ Response body: $db_response_body"
        
        if [ "$db_http_code" = "200" ]; then
          echo "  ‚úÖ Database connectivity is healthy"
        elif [ "$db_http_code" = "401" ]; then
          echo "  ‚ö†Ô∏è Database connectivity check failed (HTTP 401)"
          echo "  üîç This is expected for a fresh development deployment or missing migrations"
        else
          echo "  ‚ö†Ô∏è Database connectivity check failed (HTTP $db_http_code)"
          echo "  üîç This may be due to empty database or missing migrations"
        fi
        
    - name: Verify deployment status
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      run: |
        echo "üîç Verifying development deployment..."
        
        # Check if we can access the Supabase API
        echo "üì° Testing Supabase API connectivity..."
        response=$(curl -s -w "\n%{http_code}" -X GET ${{ secrets.SUPABASE_URL }}/rest/v1/ \
          -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
          -H "Content-Type: application/json")
        
        http_code=$(echo "$response" | tail -n1)
        if [ "$http_code" = "200" ]; then
          echo "‚úÖ Supabase API is accessible"
        else
          echo "‚ö†Ô∏è Supabase API connectivity check failed (HTTP $http_code)"
          echo "This may be normal for a fresh deployment"
        fi
        
        # Check migration status
        echo ""
        echo "üóÑÔ∏è Checking migration status..."
        cd supabase
        if [ -d "migrations" ] && [ "$(ls -A migrations)" ]; then
          echo "‚úÖ Migrations directory contains files:"
          ls -la migrations/
          
          # List deployed functions
          echo ""
          echo "üîß Checking deployed functions..."
          supabase functions list --project-ref ${{ secrets.SUPABASE_DEVELOP_PROJECT }} || echo "Could not list functions"
        else
          echo "‚ö†Ô∏è No migrations found"
        fi
        
        # Check database schema
        echo ""
        echo "üìã Checking database schema..."
        echo "Testing content_blocks table status constraint..."
        
        # Test if the status constraint allows content_ready and content_failed
        test_query="SELECT status FROM content_blocks WHERE status IN ('content_ready', 'content_failed') LIMIT 1;"
        
        # This will fail if the constraint doesn't allow these statuses
        schema_test=$(curl -s -w "\n%{http_code}" -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/rpc/exec_sql" \
          -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
          -H "Content-Type: application/json" \
          -d "{\"query\": \"$test_query\"}" 2>/dev/null || echo "Schema test failed")
        
        echo "Schema constraint test result: $schema_test"
        
        echo "‚úÖ Deployment verification complete"
        
    - name: Notify deployment success
      if: success()
      run: |
        echo "üéâ Successfully deployed to development!"
        echo "Project: ${{ secrets.SUPABASE_DEVELOP_PROJECT }}"
        echo "Deployment time: $(date)"
        echo "Commit: ${{ github.sha }}"
        echo "Supabase URL: ${{ secrets.SUPABASE_URL }}"
        
  deployment-failed:
    name: Development Deployment Failed
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
    - name: Notify failure
      run: |
        echo "‚ùå Development deployment failed!"
        echo "Please check the logs and fix any issues before retrying."
        echo "Project: ${{ secrets.SUPABASE_DEVELOP_PROJECT }}"
        echo "Commit: ${{ github.sha }}"
        echo "Supabase URL: ${{ secrets.SUPABASE_URL }}"
        
    - name: Rollback guidance
      run: |
        echo "üîÑ Rollback guidance:"
        echo "1. Check Supabase dashboard for deployment status"
        echo "2. Review function logs for errors"
        echo "3. Verify environment variables are correctly set"
        echo "4. Check database migration status"
        echo "5. Manual rollback may be required via Supabase dashboard" 